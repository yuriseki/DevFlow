import ast
import os
import re
from pathlib import Path

# This script generates TypeScript type definition files (.d.ts) in frontend/types/
# based on the SQLModel Python classes found in backend/app/features/**/models/*.py.
# It uses Python's Abstract Syntax Trees (AST) to parse the Python source code,
# ensuring a more robust translation than simple text parsing.

# --- Configuration ---
# The root directory of the backend features.
BACKEND_FEATURES_DIR = Path("backend/app/features")
# The target directory for the generated TypeScript type files.
FRONTEND_TYPES_DIR = Path("frontend/types")
# A header to add to the top of each generated file.
SCRIPT_HEADER = "// This file is auto-generated by a script. Do not edit.\n\n"

# --- Type Mapping ---
# A dictionary to map Python type hints to their TypeScript equivalents.
PYTHON_TO_TS_TYPE_MAP = {
    "str": "string",
    "int": "number",
    "float": "number",
    "bool": "boolean",
    "datetime": "string",
    "Any": "any",
    "dict": "Record<string, any>",
    "Dict": "Record<string, any>",
}


def get_ts_type(py_type_node: ast.AST | None) -> str:
    """
    Recursively converts an AST type annotation node to a TypeScript type string.
    Handles simple types, optionals (T | None), lists (List[T]), and forward references.
    """
    if py_type_node is None:
        return "any"
    if isinstance(py_type_node, ast.Name):
        return PYTHON_TO_TS_TYPE_MAP.get(py_type_node.id, py_type_node.id)
    if isinstance(py_type_node, ast.Constant) and isinstance(py_type_node.value, str):
        # Handles forward references as strings, e.g., "User"
        return py_type_node.value
    if isinstance(py_type_node, ast.Subscript):
        # Handles generic types like List[T] and Optional[T]
        base_type = get_ts_type(py_type_node.value)
        slice_type = get_ts_type(py_type_node.slice)
        if base_type == "List":
            return f"{slice_type}[]"
        if base_type == "Optional":
            return f"{slice_type} | null"
        # Fallback for other generics, e.g., Dict[str, int]
        return f"{base_type}<{slice_type}>"
    if isinstance(py_type_node, ast.BinOp) and isinstance(py_type_node.op, ast.BitOr):
        # Handles the `|` operator for union types, e.g., str | None
        left = get_ts_type(py_type_node.left)
        right = get_ts_type(py_type_node.right)
        if right == "NoneType":  # Special case for `| None`
            return f"{left} | null"
        return f"{left} | {right}"
    # Handles `None` in type hints, which parses to a Constant
    if isinstance(py_type_node, ast.Constant) and py_type_node.value is None:
        return "NoneType"
    return "any"


class ModelVisitor(ast.NodeVisitor):
    """
    An AST visitor that walks the Python source tree and extracts definitions
    for SQLModel classes and Enums, preparing them for TypeScript conversion.
    """

    def __init__(self):
        self.interfaces = {}
        self.enums = {}
        self.imports = set()

    def visit_ClassDef(self, node: ast.ClassDef):
        # Check if the class is a SQLModel or an Enum by inspecting its base classes.
        is_sqlmodel = any(
            isinstance(b, ast.Name) and "SQLModel" in b.id for b in node.bases
        )
        is_enum = any(isinstance(b, ast.Name) and "Enum" in b.id for b in node.bases)

        # If it's an Enum, extract its members.
        if is_enum:
            self.enums[node.name] = []
            for item in node.body:
                if isinstance(item, ast.Assign) and isinstance(item.value, ast.Constant):
                    for target in item.targets:
                        if isinstance(target, ast.Name):
                            self.enums[node.name].append(
                                f'  {target.id} = "{item.value.value}",'
                            )
            return  # Stop further visiting within this class

        # If it's a SQLModel or inherits from a 'Base' model, process it as an interface.
        is_base_model_inheritance = any(
            isinstance(b, ast.Name) and b.id.endswith("Base") for b in node.bases
        )
        if is_sqlmodel or is_base_model_inheritance:
            interface = {
                "name": node.name,
                "fields": [],
                "extends": [
                    get_ts_type(b)
                    for b in node.bases
                    if get_ts_type(b) not in ["SQLModel", "BaseModel"]
                ],
            }
            for field_node in node.body:
                if isinstance(field_node, ast.AnnAssign):
                    field_name = field_node.target.id
                    # Skip private attributes and table arguments
                    if field_name.startswith("__"):
                        continue

                    ts_type = get_ts_type(field_node.annotation)
                    is_optional = "| null" in ts_type or "Optional" in ast.dump(
                        field_node.annotation
                    )

                    # Attempt to generate imports for related types
                    clean_type = (
                        ts_type.replace("[]", "").replace("| null", "").strip()
                    )
                    if (
                        clean_type[0].isupper()
                        and clean_type not in self.interfaces
                        and clean_type not in self.enums
                        and clean_type != node.name
                    ):
                        # Convert PascalCase to snake_case for the filename
                        import_file = re.sub(
                            r"(?<!^)(?=[A-Z])", "_", clean_type
                        ).lower()
                        self.imports.add(
                            f"import {{ type {clean_type} }} from '@frontend/types/{import_file}';"
                        )

                    interface["fields"].append(
                        f"  {field_name}{'?' if is_optional else ''}: {ts_type};"
                    )
            self.interfaces[node.name] = interface
        # Continue visiting nested classes
        self.generic_visit(node)


def generate_ts_from_py_model(file_path: Path) -> str:
    """
    Parses a single Python model file and returns a string containing
    the equivalent TypeScript definitions.
    """
    source = file_path.read_text()
    tree = ast.parse(source)
    visitor = ModelVisitor()
    visitor.visit(tree)

    output_parts = []

    # Add generated imports
    if visitor.imports:
        output_parts.append("\n".join(sorted(list(visitor.imports))))

    # Add enums
    for enum_name, members in visitor.enums.items():
        output_parts.append(
            f"export enum {enum_name} {{\n" + "\n".join(members) + "\n}}"
        )

    # Sort interfaces to ensure base classes are defined before derived ones.
    sorted_interfaces = sorted(
        visitor.interfaces.values(),
        key=lambda i: (not i["name"].endswith("Base"), i["name"]),
    )

    # Add interfaces
    for interface in sorted_interfaces:
        extends_str = ""
        if interface["extends"]:
            extends_str = f" extends {', '.join(interface['extends'])}"

        # Handle special case for empty 'Update' schemas, converting them to Partial<T>
        is_update_schema = interface["name"].endswith("Update")
        has_no_fields = not interface["fields"]
        base_name_from_extends = (
            interface["extends"][0] if interface["extends"] else None
        )
        base_name_from_convention = interface["name"].replace("Update", "Base")

        if is_update_schema and has_no_fields:
            if base_name_from_extends:
                output_parts.append(
                    f"export type {interface['name']} = Partial<{base_name_from_extends}>;"
                )
            elif base_name_from_convention in visitor.interfaces:
                output_parts.append(
                    f"export type {interface['name']} = Partial<{base_name_from_convention}>;"
                )
            continue  # Skip the standard interface generation

        # Standard interface generation
        fields_str = "\n".join(interface["fields"])
        output_parts.append(
            f"export interface {interface['name']}{extends_str} {{\n{fields_str}\n}}"
        )

    return "\n\n".join(output_parts)


def main():
    """
    Main execution function. Iterates through backend feature directories,
    finds model files, generates TypeScript definitions, and writes them
    to the corresponding files in the frontend types directory.
    """
    if not FRONTEND_TYPES_DIR.exists():
        print(f"Creating directory: {FRONTEND_TYPES_DIR}")
        FRONTEND_TYPES_DIR.mkdir(parents=True, exist_ok=True)

    feature_dirs = sorted([d for d in BACKEND_FEATURES_DIR.iterdir() if d.is_dir()])

    for feature_dir in feature_dirs:
        models_dir = feature_dir / "models"
        if not models_dir.exists():
            continue

        # Combine all model files within a feature into one .d.ts file
        ts_output_content = []
        model_files = sorted([f for f in models_dir.glob("*.py") if not f.name.startswith("__")])

        for model_file in model_files:
            print(f"Processing {model_file}...")
            ts_output_content.append(generate_ts_from_py_model(model_file))

        if ts_output_content:
            # Use snake_case for the output filename
            ts_file_name = f"{feature_dir.name}.d.ts"
            output_path = FRONTEND_TYPES_DIR / ts_file_name
            print(f"Writing TypeScript definitions to {output_path}")
            
            # Filter out empty results and join
            full_content = "\n\n".join(filter(None, ts_output_content))
            
            with open(output_path, "w") as f:
                f.write(SCRIPT_HEADER)
                f.write(full_content)
                f.write("\n") # Ensure trailing newline

    print("\nDone.")


if __name__ == "__main__":
    main()
