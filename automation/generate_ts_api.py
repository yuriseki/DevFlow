import json
import ast
from pathlib import Path
import re

# --- Configuration ---
BACKEND_FEATURES_DIR = Path("backend/app/features")
FRONTEND_DIR = Path("frontend")
FRONTEND_LIB_DIR = FRONTEND_DIR / "lib"
FRONTEND_API_DIR = FRONTEND_LIB_DIR / "api"
SCRIPT_DIR = Path(__file__).parent.resolve()
TEMPLATES_SOURCE_DIR = SCRIPT_DIR / "templates" / "ts" / "lib"
SCRIPT_HEADER = "// This file is auto-generated by a script. Do not edit.\n\n"

def check_npm_dependencies():
    """Checks if required npm dependencies are installed in the frontend project."""
    print("\n--- Checking npm dependencies ---")
    package_json_path = FRONTEND_DIR / "package.json"
    if not package_json_path.exists():
        print(f"Error: 'package.json' not found in frontend directory: {package_json_path}")
        print("Please ensure the frontend project is set up correctly.")
        exit(1)

    with open(package_json_path, 'r') as f:
        package_json = json.load(f)

    dependencies = package_json.get('dependencies', {})
    dev_dependencies = package_json.get('devDependencies', {})

    missing_dependencies = []
    REQUIRED_NPM_DEPENDENCIES = {
        "zod": "zod",
        "pino": "pino"
    }

    for module_name, package_name in REQUIRED_NPM_DEPENDENCIES.items():
        if package_name not in dependencies and package_name not in dev_dependencies:
            missing_dependencies.append(package_name)

    if missing_dependencies:
        print("\nError: Some required npm dependencies are missing from 'frontend/package.json'.")
        print("Please install them by running the following commands in the 'frontend/' directory:")
        for dep in missing_dependencies:
            print(f"  npm install {dep}")
        print("\nAfter installing, please run this script again.")
        exit(1)
    
    print("All required npm dependencies are in place.")

# --- Template Files Check ---
REQUIRED_TEMPLATE_FILES = [
    "handlers/apiFetch.ts",
    "handlers/error.ts",
    "http-errors.ts",
    "logger.ts",
]

def check_template_files():
    """
    Checks if all required frontend utility files exist and their content matches the expected
    from the templates source directory. Prompts the user for action if mismatches are found.
    """
    all_templates_ok = True
    print("\n--- Checking frontend utility files ---")

    for template_file_name in REQUIRED_TEMPLATE_FILES:
        frontend_path = FRONTEND_LIB_DIR / template_file_name
        source_template_path = TEMPLATES_SOURCE_DIR / template_file_name

        # 1. Ensure the source template file exists
        if not source_template_path.exists():
            print(f"\nCritical Error: Source template file not found: {source_template_path}")
            print("Please ensure the canonical template files exist in the 'automation/templates/ts/lib/' directory.")
            exit(1)
        
        source_template_content = source_template_path.read_text()

        # 2. Check frontend file existence and content
        if not frontend_path.exists():
            print(f"\nMissing frontend utility file: {frontend_path}")
            response = input(f"Do you want to create '{frontend_path}' with content from '{source_template_path}'? (y/N): ").lower()
            if response == 'y':
                frontend_path.parent.mkdir(parents=True, exist_ok=True)
                frontend_path.write_text(source_template_content)
                print(f"Created {frontend_path}.")
            else:
                print(f"Skipping creation for {frontend_path}. Please create it manually if needed.")
                all_templates_ok = False
        else:
            current_frontend_content = frontend_path.read_text()
            # Using content comparison as a proxy for "function signature" check
            if current_frontend_content.strip() != source_template_content.strip():
                print(f"\nFrontend utility file content mismatch for: {frontend_path}")
                print(f"Content of '{frontend_path}' differs from the template '{source_template_path}'.")
                print("This might indicate a difference in function signatures or other critical code.")
                response = input(f"Do you want to replace '{frontend_path}' with content from '{source_template_path}'? (y/N): ").lower()
                if response == 'y':
                    frontend_path.write_text(source_template_content)
                    print(f"Replaced {frontend_path} with the correct content.")
                else:
                    print(f"Skipping replacement for {frontend_path}. Please update it manually if needed.")
                    all_templates_ok = False
            else:
                print(f"Frontend utility file '{frontend_path}' is up-to-date.")
    
    if not all_templates_ok:
        print("\nSome frontend utility files require attention. Please address them before proceeding.")
        exit(1)
    print("\nAll required frontend utility files are present and up-to-date.")

# --- Type Mapping ---
PYTHON_TO_TS_TYPE_MAP = {
    "str": "string",
    "int": "number",
    "float": "number",
    "bool": "boolean",
}

# --- Helper Functions ---

def to_camel_case(snake_str: str) -> str:
    """Converts a snake_case string to camelCase."""
    components = snake_str.split('_')
    return components[0] + ''.join(x.title() for x in components[1:])

def get_ts_type(node: ast.AST | None) -> str:
    """
    Extracts a type name as a string from an AST annotation node.
    """
    if node is None:
        return "any"
    if isinstance(node, ast.Name):
        return PYTHON_TO_TS_TYPE_MAP.get(node.id, node.id)
    if isinstance(node, ast.Subscript):
        base = get_ts_type(node.value)
        slice_type = get_ts_type(node.slice)
        if base == "List":
            return f"{slice_type}[]"
        return slice_type
    # Handle Union types (e.g., str | None)
    if isinstance(node, ast.BinOp) and isinstance(node.op, ast.BitOr):
        left_type = get_ts_type(node.left)
        right_type = get_ts_type(node.right)
        # If one of them is None, it's an Optional type
        if right_type == "NoneType": # Python's None is ast.Constant(value=None)
            return left_type
        if left_type == "NoneType":
            return right_type
        return f"{left_type} | {right_type}"
    if isinstance(node, ast.Constant) and node.value is None:
        return "NoneType" # Special internal representation for None
    return "any" # Default for unhandled types

class RouterVisitor(ast.NodeVisitor):
    """Finds the APIRouter prefix."""
    def __init__(self):
        self.prefix = ""

    def visit_Assign(self, node: ast.Assign):
        if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id == 'APIRouter':
            for keyword in node.value.keywords:
                if keyword.arg == 'prefix' and isinstance(keyword.value, ast.Constant):
                    self.prefix = keyword.value.value
        self.generic_visit(node)

class RouteVisitor(ast.NodeVisitor):
    """AST visitor to extract FastAPI route definitions."""
    def __init__(self, feature_name: str):
        self.routes = []
        self.imports = set()
        self.feature_name = feature_name

    def visit_FunctionDef(self, node: ast.FunctionDef):
        self.process_function(node)

    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef):
        self.process_function(node)

    def process_function(self, node: ast.FunctionDef | ast.AsyncFunctionDef):
        for decorator in node.decorator_list:
            if not (isinstance(decorator, ast.Call) and isinstance(decorator.func, ast.Attribute)):
                continue
            if not (isinstance(decorator.func.value, ast.Name) and 'router' in decorator.func.value.id):
                continue

            http_method = decorator.func.attr.upper()
            if http_method not in ["GET", "POST", "PUT", "DELETE"]:
                continue

            path = decorator.args[0].value if decorator.args and isinstance(decorator.args[0], ast.Constant) else "/"
            
            response_model = "void"
            for kw in decorator.keywords:
                if kw.arg == 'response_model':
                    response_model = get_ts_type(kw.value)
                    clean_type = response_model.replace("[]", "")
                    if clean_type and clean_type[0].isupper():
                        self.imports.add(clean_type)

            path_params_in_url = re.findall(r'{(\w+)}', path)
            ts_function_params = []
            body_arg_details = None
            query_params_details = []
            
            # Collect all Python function arguments
            python_args = []
            for arg in node.args.args:
                python_args.append({'name': arg.arg, 'annotation': arg.annotation, 'default': arg.default if hasattr(arg, 'default') else None})
            for arg in node.args.kwonlyargs:
                python_args.append({'name': arg.arg, 'annotation': arg.annotation, 'default': arg.default if hasattr(arg, 'default') else None})

            # Filter out dependencies first
            valid_args = []
            for arg_info in python_args:
                arg_name = arg_info['name']
                arg_annotation_node = arg_info['annotation']
                arg_default_node = arg_info['default']

                if arg_name == 'self':
                    continue

                is_dependency = False
                if arg_default_node and isinstance(arg_default_node, ast.Call) and isinstance(arg_default_node.func, ast.Name) and arg_default_node.func.id == 'Depends':
                    is_dependency = True
                
                arg_type_str_temp = get_ts_type(arg_annotation_node)
                if 'Session' in arg_type_str_temp:
                    is_dependency = True
                
                if is_dependency:
                    continue
                
                valid_args.append(arg_info)

            # Find body argument from valid args for non-GET requests
            if http_method in ["POST", "PUT"]:
                for arg_info in valid_args:
                    arg_name = arg_info['name']
                    arg_type_str = get_ts_type(arg_info['annotation'])
                    is_complex_type = arg_type_str and arg_type_str[0].isupper() and "[]" not in arg_type_str and arg_type_str not in PYTHON_TO_TS_TYPE_MAP.values()

                    if is_complex_type and not body_arg_details:
                        body_arg_details = {"name": arg_name, "type": arg_type_str}
                        if arg_type_str and arg_type_str[0].isupper():
                            self.imports.add(arg_type_str)
                        break

            # Categorize all valid args
            for arg_info in valid_args:
                arg_name = arg_info['name']
                arg_type_str = get_ts_type(arg_info['annotation'])

                if body_arg_details and arg_name == body_arg_details['name']:
                    ts_function_params.append(f"{arg_name}: {arg_type_str}")
                    continue

                if arg_name in path_params_in_url:
                    ts_function_params.append(f"{to_camel_case(arg_name)}: {arg_type_str}")
                    continue

                ts_function_params.append(f"{to_camel_case(arg_name)}: {arg_type_str}")
                query_params_details.append({'name': arg_name, 'ts_name': to_camel_case(arg_name), 'type': arg_type_str})

            if http_method == "DELETE":
                body_arg_details = None

            func_name = to_camel_case(node.name)

            self.routes.append({
                "name": func_name,
                "http_method": http_method,
                "path": path,
                "ts_params_str": ", ".join(ts_function_params),
                "body_arg": body_arg_details,
                "query_params": query_params_details,
                "response_model": response_model
            })
        self.generic_visit(node)

def generate_ts_api_calls(file_path: Path, feature_name: str) -> str:
    source = file_path.read_text()
    try:
        tree = ast.parse(source)
    except SyntaxError as e:
        print(f"Could not parse {file_path}: {e}")
        return ""
    
    router_visitor = RouterVisitor()
    router_visitor.visit(tree)
    prefix = router_visitor.prefix

    route_visitor = RouteVisitor(feature_name)
    route_visitor.visit(tree)

    if not route_visitor.routes:
        return ""

    imports_str = "import { fetchHandler } from '@/lib/handlers/apiFetch';\n"
    imports_str += "import { ActionResponse } from '@/types/global';\n"
    if route_visitor.imports:
        type_imports = ", ".join(sorted(list(route_visitor.imports)))
        type_file_name = feature_name
        imports_str += f"import {{ type {type_imports} }} from '@/types/{type_file_name}';\n"

    api_calls = []
    for route in route_visitor.routes:
        full_path = f"{prefix}{route['path']}"
        
        if full_path.endswith('/') and full_path != '/':
            full_path = full_path.rstrip('/')

        path_param_map = {param: to_camel_case(param) for param in re.findall(r'{(\w+)}', full_path)}
        
        options = [f'method: "{route["http_method"]}"']
        
        if route['body_arg'] and route['http_method'] in ['POST', 'PUT']:
            body_arg = route['body_arg']
            if body_arg.get("embed"):
                options.append(f'body: JSON.stringify({{ {body_arg["name"]}: {body_arg["name"]} }})')
            else:
                options.append(f'body: JSON.stringify({body_arg["name"]})')
        
        options_str = ""
        if len(options) > 1 or route['http_method'] not in ['GET']:
            options_joined = ",\n      ".join(options)
            options_str = f", {{\n      {options_joined}\n    }}"

        # Handle query parameters
        if route['query_params']:
            params_body = "    const params = new URLSearchParams();\n"
            for qp in route['query_params']:
                ts_name = qp['ts_name']
                py_name = qp['name']
                if qp['type'] == 'string':
                    params_body += f"    if ({ts_name}) params.append('{py_name}', {ts_name});\n"
                else:
                    params_body += f"    if ({ts_name} !== undefined && {ts_name} !== null) params.append('{py_name}', {ts_name}.toString());\n"

            base_url_for_template = re.sub(r'{(\w+)}', lambda m: f'${{{path_param_map[m.group(1)]}}}', full_path)
            url_with_query = f"`{base_url_for_template}?${{params.toString()}}`"

            api_calls.append(
                f"  {route['name']}: ({route['ts_params_str']}): Promise<ActionResponse<{route['response_model']}>> => {{\n"
                f"{params_body}"
                f"    return fetchHandler({url_with_query}{options_str});\n"
                f"  }},"
            )
        else:
            # Original logic for routes without query params
            url = re.sub(r'{(\w+)}', lambda m: f'${{{path_param_map[m.group(1)]}}}', full_path)
            url = f"`{url}`"

            api_calls.append(
                f"  {route['name']}: ({route['ts_params_str']}): Promise<ActionResponse<{route['response_model']}>> =>\n"
                f"    fetchHandler({url}{options_str}),"
            )

    api_object_name = f"api{feature_name.title().replace('_', '')}"
    full_api_obj = (
        f"export const {api_object_name} = {{\n"
        + "\n\n".join(api_calls)
        + "\n};")

    return f"{imports_str}\n{full_api_obj}\n"

def main():
    check_npm_dependencies()
    check_template_files()
    if not FRONTEND_API_DIR.exists():
        FRONTEND_API_DIR.mkdir(parents=True, exist_ok=True)

    feature_dirs = sorted([d for d in BACKEND_FEATURES_DIR.iterdir() if d.is_dir()])

    for feature_dir in feature_dirs:
        routes_file = feature_dir / "routes.py"
        if not routes_file.exists():
            continue
        
        feature_name = feature_dir.name
        print(f"Processing routes for feature: {feature_name}...")

        ts_content = generate_ts_api_calls(routes_file, feature_name)

        if ts_content.strip():
            ts_file_name = f"api{feature_name.title().replace('_', '')}.ts"
            output_path = FRONTEND_API_DIR / ts_file_name
            print(f"Writing TypeScript API calls to {output_path}")
            with open(output_path, "w") as f:
                f.write(SCRIPT_HEADER)
                f.write(ts_content)

    print("\nDone.")

if __name__ == "__main__":
    main()
