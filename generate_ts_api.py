import ast
from pathlib import Path
import re

# --- Configuration ---
BACKEND_FEATURES_DIR = Path("backend/app/features")
FRONTEND_API_DIR = Path("frontend/lib/api")
SCRIPT_HEADER = "// This file is auto-generated by a script. Do not edit.\n\n"

# --- Type Mapping ---
PYTHON_TO_TS_TYPE_MAP = {
    "str": "string",
    "int": "number",
    "float": "number",
    "bool": "boolean",
}

# --- Helper Functions ---

def to_camel_case(snake_str: str) -> str:
    """Converts a snake_case string to camelCase."""
    components = snake_str.split('_')
    return components[0] + ''.join(x.title() for x in components[1:])

def get_ts_type(node: ast.AST | None) -> str:
    """
    Extracts a type name as a string from an AST annotation node.
    """
    if node is None:
        return "any"
    if isinstance(node, ast.Name):
        return PYTHON_TO_TS_TYPE_MAP.get(node.id, node.id)
    if isinstance(node, ast.Subscript):
        base = get_ts_type(node.value)
        slice_type = get_ts_type(node.slice)
        if base == "List":
            return f"{slice_type}[]"
        return slice_type
    # Handle Union types (e.g., str | None)
    if isinstance(node, ast.BinOp) and isinstance(node.op, ast.BitOr):
        left_type = get_ts_type(node.left)
        right_type = get_ts_type(node.right)
        # If one of them is None, it's an Optional type
        if right_type == "NoneType": # Python's None is ast.Constant(value=None)
            return left_type
        if left_type == "NoneType":
            return right_type
        return f"{left_type} | {right_type}"
    if isinstance(node, ast.Constant) and node.value is None:
        return "NoneType" # Special internal representation for None
    return "any" # Default for unhandled types

class RouterVisitor(ast.NodeVisitor):
    """Finds the APIRouter prefix."""
    def __init__(self):
        self.prefix = ""

    def visit_Assign(self, node: ast.Assign):
        if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id == 'APIRouter':
            for keyword in node.value.keywords:
                if keyword.arg == 'prefix' and isinstance(keyword.value, ast.Constant):
                    self.prefix = keyword.value.value
        self.generic_visit(node)

class RouteVisitor(ast.NodeVisitor):
    """AST visitor to extract FastAPI route definitions."""
    def __init__(self, feature_name: str):
        self.routes = []
        self.imports = set()
        self.feature_name = feature_name

    def visit_FunctionDef(self, node: ast.FunctionDef):
        self.process_function(node)

    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef):
        self.process_function(node)

    def process_function(self, node: ast.FunctionDef | ast.AsyncFunctionDef):
        for decorator in node.decorator_list:
            if not (isinstance(decorator, ast.Call) and isinstance(decorator.func, ast.Attribute)):
                continue
            if not (isinstance(decorator.func.value, ast.Name) and 'router' in decorator.func.value.id):
                continue

            http_method = decorator.func.attr.upper()
            if http_method not in ["GET", "POST", "PUT", "DELETE"]:
                continue

            path = decorator.args[0].value if decorator.args and isinstance(decorator.args[0], ast.Constant) else "/"
            
            response_model = "void"
            for kw in decorator.keywords:
                if kw.arg == 'response_model':
                    response_model = get_ts_type(kw.value)
                    clean_type = response_model.replace("[]", "")
                    if clean_type and clean_type[0].isupper():
                        self.imports.add(clean_type)

            path_params_in_url = re.findall(r'{(\w+)}', path)
            ts_function_params = []
            body_arg_details = None
            
            # Collect all Python function arguments
            python_args = []
            for arg in node.args.args:
                python_args.append({'name': arg.arg, 'annotation': arg.annotation, 'default': arg.default if hasattr(arg, 'default') else None})
            for arg in node.args.kwonlyargs:
                python_args.append({'name': arg.arg, 'annotation': arg.annotation, 'default': arg.default if hasattr(arg, 'default') else None})

            for arg_info in python_args:
                arg_name = arg_info['name']
                arg_annotation_node = arg_info['annotation']
                arg_default_node = arg_info['default']
                arg_type_str = get_ts_type(arg_annotation_node)

                # Skip 'self'
                if arg_name == 'self':
                    continue

                # Skip FastAPI dependency injections (like session: AsyncSession = Depends(...))
                is_dependency = False
                if arg_default_node and isinstance(arg_default_node, ast.Call) and isinstance(arg_default_node.func, ast.Name) and arg_default_node.func.id == 'Depends':
                    is_dependency = True
                if arg_annotation_node and isinstance(arg_annotation_node, ast.Name) and arg_annotation_node.id == 'AsyncSession':
                    is_dependency = True
                if is_dependency:
                    continue

                # If it's a path parameter
                if arg_name in path_params_in_url:
                    ts_function_params.append(f"{to_camel_case(arg_name)}: number")
                    continue

                # Check for embedded body (e.g., email: str = Body(..., embed=True))
                is_embedded_body = False
                if arg_default_node and isinstance(arg_default_node, ast.Call) and isinstance(arg_default_node.func, ast.Name) and arg_default_node.func.id == 'Body':
                    for kw in arg_default_node.keywords:
                        if kw.arg == 'embed' and isinstance(kw.value, ast.Constant) and kw.value.value is True:
                            is_embedded_body = True
                
                if is_embedded_body:
                    ts_function_params.append(f"{arg_name}: {arg_type_str}")
                    body_arg_details = {"name": arg_name, "type": arg_type_str, "embed": True}
                    if arg_type_str and arg_type_str[0].isupper():
                        self.imports.add(arg_type_str)
                # If it's a regular body argument (e.g., user: UserCreate)
                elif arg_annotation_node:
                    # This is the main body payload
                    ts_function_params.append(f"{arg_name}: {arg_type_str}")
                    body_arg_details = {"name": arg_name, "type": arg_type_str}
                    if arg_type_str and arg_type_str[0].isupper():
                        self.imports.add(arg_type_str)
            
            # Do not set body_arg_details for DELETE requests
            if http_method == "DELETE":
                body_arg_details = None

            # Simplified function name generation
            func_name = to_camel_case(node.name)

            self.routes.append({
                "name": func_name,
                "http_method": http_method,
                "path": path,
                "ts_params_str": ", ".join(ts_function_params),
                "body_arg": body_arg_details,
                "response_model": response_model
            })
        self.generic_visit(node)

def generate_ts_api_calls(file_path: Path, feature_name: str) -> str:
    source = file_path.read_text()
    try:
        tree = ast.parse(source)
    except SyntaxError as e:
        print(f"Could not parse {file_path}: {e}")
        return ""
    
    router_visitor = RouterVisitor()
    router_visitor.visit(tree)
    prefix = router_visitor.prefix

    route_visitor = RouteVisitor(feature_name)
    route_visitor.visit(tree)

    if not route_visitor.routes:
        return ""

    imports_str = "import { fetchHandler } from '@/lib/apiFetch';\n"
    imports_str += "import { ActionResponse } from '@/types/global';\n"
    if route_visitor.imports:
        type_imports = ", ".join(sorted(list(route_visitor.imports)))
        # Adjust import path for snake_case filenames
        # Special handling for user_collection as its type file is user_collection.d.ts
        # and not usercollection.d.ts
        type_file_name = feature_name
        if feature_name == "user_collection":
            type_file_name = "user_collection"
        else:
            type_file_name = re.sub(r'(?<!^)(?=[A-Z])', '_', feature_name).lower()

        imports_str += f"import {{ type {type_imports} }} from '@/types/{type_file_name}';\n"

    api_calls = []
    for route in route_visitor.routes:
        full_path = f"{prefix}{route['path']}"
        
        # Strip trailing slash unless it's the root path
        if full_path.endswith('/') and full_path != '/':
            full_path = full_path.rstrip('/')

        # Create a mapping from snake_case path param to camelCase path param for URL interpolation
        path_param_map = {param: to_camel_case(param) for param in re.findall(r'{(\w+)}', full_path)}
        
        # Replace {snake_case_param} with ${camelCaseParam}
        url = re.sub(r'{(\w+)}', lambda m: f'${{{path_param_map[m.group(1)]}}}', full_path)
        url = f"`{url}`" # Wrap in backticks for template literal

        options = [f'method: "{route["http_method"]}"']
        
        # Only add body for POST and PUT requests
        if route['body_arg'] and route['http_method'] in ['POST', 'PUT']:
            body_arg = route['body_arg']
            if body_arg.get("embed"):
                options.append(f'body: JSON.stringify({{ {body_arg["name"]}: {body_arg["name"]} }})')
            else:
                options.append(f'body: JSON.stringify({body_arg["name"]})')
        
        options_str = ""
        # Only add options if there's more than just the method, or if it's not a GET request (to explicitly set method)
        if len(options) > 1 or route['http_method'] not in ['GET']:
            options_joined = ",\n      ".join(options)
            options_str = f", {{\n      {options_joined}\n    }}"

        api_calls.append(
            f"  {route['name']}: ({route['ts_params_str']}): Promise<ActionResponse<{route['response_model']}>> =>\n"
            f"    fetchHandler({url}{options_str}),"
        )

    api_object_name = f"api{feature_name.title().replace('_', '')}"
    full_api_obj = (
        f"export const {api_object_name} = {{\n"
        + "\n\n".join(api_calls)
        + "\n};")

    return f"{imports_str}\n{full_api_obj}\n"

def main():
    if not FRONTEND_API_DIR.exists():
        FRONTEND_API_DIR.mkdir(parents=True, exist_ok=True)

    feature_dirs = sorted([d for d in BACKEND_FEATURES_DIR.iterdir() if d.is_dir()])

    for feature_dir in feature_dirs:
        routes_file = feature_dir / "routes.py"
        if not routes_file.exists():
            continue
        
        feature_name = feature_dir.name
        print(f"Processing routes for feature: {feature_name}...")

        ts_content = generate_ts_api_calls(routes_file, feature_name)

        if ts_content.strip():
            ts_file_name = f"api{feature_name.title().replace('_', '')}.ts"
            output_path = FRONTEND_API_DIR / ts_file_name
            print(f"Writing TypeScript API calls to {output_path}")
            with open(output_path, "w") as f:
                f.write(SCRIPT_HEADER)
                f.write(ts_content)

    print("\nDone.")

if __name__ == "__main__":
    main()
